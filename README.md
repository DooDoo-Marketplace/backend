# Docker
Возможно, мы сделаем так, чтобы url бд не менялся строкой, но не суть... 

Вот команда для запуска всего:
```bash
docker-compose up --build
```
И также в docker-compose.yml запускаете сервис.

# Тесты

Используем JUnit 5 и Mockito. Все репозитории мы мокаем, и инжектим в нужный сервис. Для этого есть удобные аннотации @Mock и @InjectMocks.
Для запуска тестов также нужно добавить Extension - MockitoExtension. Каждый класс тетсирует отдельный модуль (класс или может даже его часть).
Каждый метод проверяет отдельный маленький кейс, вызывает один метод. Формат названия тестирующих методов: 
methodName_shouldDoSmth_whenCondition, when - опицональная часть. Пока покрываем тестами только сервисы и фильтры. 
Остальное, например контроллеры, мапперы и прочее - в исключительных случаях.
Тесты для класса мы пишем по тому же пути, что и этот класс, только в директории test, а не java

# Liquibase
Чтобы запуститься с заполненными чем-то таблицами - в resources/application.properties пишете spring.liquibase.contexts=test, если без - spring.liquibase.contexts=prod

Вам нужно накатить изменения в бд для выполнения такси - создаете sql скрипт и rollback к нему.
Создаете в директории changes xml файл с назаванием ветки и комментарием (например DBEB-10-create-logs-table.xml), где добавляете changeSet с sql скриптами.
И этот файл включаем в главный changelog-master.xml. При больших изменениях ставьте тег, чтобы потом к нему вернуться если что.

Если у вас при локальной разработке приложение падает с "какой-то ошибкой чек сумм", значит вы скорее всего изменили накатанные скрипты, так делать не нужно! Создавайте новые скрипты и добавляйте их, как указано выше. 
Если что крайний фикс - снести локальные таблицы и накатить скрипты заново.

Примеры роллбеков:
1. По тегу: mvn liquibase:rollback -Dliquibase.rollbackTag=\<tag name>
2. Откатиться на n версий назад: mvn liquibase:rollback -Dliquibase.rollbackCount=\<n>
3. По дате: mvn liquibase:rollback "-Dliquibase.rollbackDate=Jun 22, 2021"

В интернете можно найти еще много примеров. Важно, что в локальной бд в докере роллбеки не работают, это норма, и там это особо не нужно. В теории можно настроить бд в докере, чтобы так сделать было можно, но я не стал тратить на это время.

# Git
Две основные ветки main и dev. В main последняя релизнутая версия, в dev - последняя версия разработки.
Для текущей задачи создаете свою ветку от dev с названием как в Jir'е (DBEB-"N"), делаете таску, пушите ее и создаете пулл реквест.

Перед мержем пулл реквеста сквоште коммиты, это можно делать в самом гитхабе, на кнопке merge pull request можно выбрать вариацию squash and merge.

Свои коммиты называйте в формате: DBEB-"N" "comment". Например DBEB-10 bug fixed

### Как подтянуть изменения из dev'a к себе:
Если у вас несколько коммитов то засквошьте их, туториал ниже. Если вы этого не сделаете, то решение конфликтов с чужими изменениями не будет возможным.

После этого вам нужно спулить dev к себе, и вмержить dev в свою ветку. Т.е вы пулите dev,  потом из свой ветки пишите
```bash
git merge dev
```
Работа не с dev, а другой веткой делается аналогично 
### Как сквошить коммиты:
Пишите git rebase -i HEAD~n (n - количество коммитов)

Дальше у вас откроется вим, в котором первый pick оставляете, а в остальных меняете pick на s.

И потом выходите (esc -> :wq!) (В терминале идеи на esc будет уходить таргет с терминала, просто вернитесь на терминал и пишите :wq!)

Потом останется только выбрать комментарий к общему коммиту и опять выйти

### 

#   Шедулер
Используем Quartz Scheduler. 

Основные понятия:

1) Job - реализуете интерфейс Job и в методе execute пишите бизнес логику
2) JobDetail - содержит в себе Job и всё, что нужно передать в Job (как доставать - SetStatusGroupJob).
3) Trigger - задаёт время, по которому будет выполняться джоба. 2 вида (основных):
    3.1) Cron Trigger = "хочу, чтобы раз в сутки делалось что-то"
    3.2) Simple Trigger = "хочу, чтобы через час сделалось что-то"
   
Работает примерно так: джоба внутри себя вызывает сервис, сервис - репу. Очень похоже на контроллер - сервис - репа, но если контроллер работает по запросу, то джоба отработает когда сработает тригер.

   
### Как сделать cron джобу
1) Заводим джобу как класс, пишем логику
2) Открываем quartz-config.xml и регаем там джобу и тригер (пример: CleanCartJob)
В данном случае джобу надо отметить как @Component, потому что спринг её сам создаст и закинет в шедулер.

### Как завести обычную джобу
1) Заводим джобу как класс, пишем логику
2) В коде создаём инстанс джобы и тригера (написаны JobFactory, TriggerFactory)
3) добавляем их к уже работающему шедулеру (пример - SetStatusGroupJob)
В данном случае джобу не надо отмечать как @Component, потому что мы сами руками её создаём и добавляем в уже работающий шедулер.
   
